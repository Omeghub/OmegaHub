wait(5)
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/ImBrokz89/test/main/addons"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/ImBrokz89/test/main/Maddons"))()

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer

local Window = Fluent:CreateWindow({
   Title = "Omega Hub I Dungeon Heroes",
   TabWidth = 160,
   Size = UDim2.fromOffset(580, 460),
   Theme = "Dark",
   Acrylic = false,
   MinimizeKey = Enum.KeyCode.End 
})

Fluent:Notify({
   Title = "Notification",
   Content = "Script injected :)",
   Duration = 2
})

local Tabs = {
    Main = Window:AddTab({ Title = "Combat", Icon = "swords" }),
    Raid = Window:AddTab({ Title = "Raid / Dungeon", Icon = "sword" }),
    Items = Window:AddTab({Title = "Items", Icon = "axe" }),
    Sell = Window:AddTab({Title = "Sell", Icon = "layers" }),
    Misc = Window:AddTab({ Title = "Misc", Icon = "flame" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

-- =========================================================
--  KILL AURA FIXÃ‰ (RESTART APRÃˆS LA MORT)

_G.KillAuraEnabled = false
_G.KillAuraRunning = false

local attackDelay = 0.2
local killAuraRange = 100
local remoteAttack = ReplicatedStorage.Systems.Combat.PlayerAttack

local function getClosestMobs()
    local char = player.Character
    if not char then return {} end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return {} end

    local mobsFolder = Workspace:WaitForChild("Mobs")
    local mobs = {}

    for _, mob in ipairs(mobsFolder:GetChildren()) do
        if mob:IsA("Model") and mob:FindFirstChild("HumanoidRootPart") then
            local dist = (hrp.Position - mob.HumanoidRootPart.Position).Magnitude
            if dist <= killAuraRange then
                table.insert(mobs, {mob = mob, distance = dist})
            end
        end
    end

    table.sort(mobs, function(a, b) return a.distance < b.distance end)

    local list = {}
    for _, m in ipairs(mobs) do
        table.insert(list, m.mob)
    end

    return list
end

local function KillAura()
    if _G.KillAuraRunning then return end
    _G.KillAuraRunning = true

    while _G.KillAuraEnabled do
        local char = player.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") then
            break
        end

        local mobs = getClosestMobs()
        local valid = {}

        for _, mob in ipairs(mobs) do
            if mob and mob.Parent and mob:FindFirstChild("HumanoidRootPart") then
                table.insert(valid, mob)
            end
        end

        if #valid > 0 then
            remoteAttack:FireServer(valid)
        end

        task.wait(attackDelay)
    end

    _G.KillAuraRunning = false
end

local Section = Tabs.Main:AddSection("Kill Aura")

Tabs.Main:AddToggle("KillAura", {
    Title = "Kill Aura",
    Callback = function(state)
        _G.KillAuraEnabled = state
        if state then task.spawn(KillAura) end
    end
})

Tabs.Main:AddSlider("AttackDelaySlider", {
    Title = "Attack Delay",
    Min = 0.2,
    Max = 1,
    Default = attackDelay,
    Rounding = 2,
    Callback = function(value)
        attackDelay = value
    end
})

-- =========================================================
-- PET KILL AURA (CLEAN + MULTI ATTACKS)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local mobsFolder = Workspace:WaitForChild("Mobs")
local remotePetAttack = ReplicatedStorage.Systems.Combat.PetDamage

local petAttackDelay = 0.2
local petKillAuraRange = 250

-- ðŸ”´ LISTE DES ATTAQUES POSSIBLES DU PET
local PET_ATTACKS = {
    "Claw",
    "Basic Attack",
    "SlamDown",
    "Stance",
    "Spear Sweep",
    "Ground Slam", -- krampus
    "soot cloud", -- krampus
    "chain whip", -- krampus
    "present throw", -- krampus
    "dark ember trail" -- krampus
}

_G.PetKillAuraEnabled = false
_G.PetKillAuraRunning = false


local function getPlayerPet()
    for _, pet in ipairs(mobsFolder:GetChildren()) do
        if pet:IsA("Model") and pet:GetAttribute("Owner") == player.Name then
            return pet
        end
    end
    return nil
end

local function getClosestMob(hrp)
    local closest, dist = nil, petKillAuraRange

    for _, mob in ipairs(mobsFolder:GetChildren()) do
        if mob:IsA("Model")
        and mob:FindFirstChild("HumanoidRootPart")
        and mob:GetAttribute("Owner") == nil then

            local d = (mob.HumanoidRootPart.Position - hrp.Position).Magnitude
            if d < dist then
                dist = d
                closest = mob
            end
        end
    end

    return closest
end

local function getValidAttack(petName)
    local mobFolder = ReplicatedStorage:FindFirstChild("Mobs")
    local petFolder = mobFolder and mobFolder:FindFirstChild(petName)
    local attacks = petFolder and petFolder:FindFirstChild("Attacks")

    if not attacks then return nil end

    for _, attackName in ipairs(PET_ATTACKS) do
        local attack = attacks:FindFirstChild(attackName)
        if attack and attack:FindFirstChild("Circle") then
            return attackName, attack.Circle
        end
    end

    return nil
end

local function PetKillAura()
    if _G.PetKillAuraRunning then return end
    _G.PetKillAuraRunning = true

    while _G.PetKillAuraEnabled do
        local pet = getPlayerPet()
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")

        if not pet or not hrp then
            task.wait(0.5)
            continue
        end

        local petHRP = pet:FindFirstChild("HumanoidRootPart")
        if petHRP then
            petHRP.CFrame = hrp.CFrame * CFrame.new(2, 0, 2)
        end

        local mob = getClosestMob(hrp)
        if mob then
            local attackName, circle = getValidAttack(pet.Name)

            if attackName and circle then
                remotePetAttack:FireServer(
                    pet,
                    attackName,
                    circle,
                    { mob }
                )
            end
        end

        task.wait(petAttackDelay)
    end

    _G.PetKillAuraRunning = false
end

local Section = Tabs.Main:AddSection("Kill Aura Pet")

Tabs.Main:AddToggle("PetKillAura", {
    Title = "Enable Pet Kill Aura",
    Default = false,
    Callback = function(state)
        _G.PetKillAuraEnabled = state
        if state then
            task.spawn(PetKillAura)
        end
    end
})

Tabs.Main:AddSlider("PetAttackDelay", {
    Title = "Attack Delay",
    Min = 0.1,
    Max = 1,
    Default = petAttackDelay,
    Rounding = 2,
    Callback = function(value)
        petAttackDelay = value
    end
})





-- =========================================================
-- AUTO START DUNGEON

_G.AutoStartDungeon = false

local function AutoStartDungeon()
    local trigger = ReplicatedStorage.Systems.Dungeons.TriggerStartDungeon

    while _G.AutoStartDungeon do
        local gui = player.PlayerGui:FindFirstChild("DungeonHUD")
        if gui and gui:FindFirstChild("StartDungeon") then
            if gui.StartDungeon.Visible then
                trigger:FireServer()
            end
        end
        task.wait(0.3)
    end
end

local Section = Tabs.Raid:AddSection("Run Control")

Tabs.Raid:AddToggle("AutoStart", {
    Title = "Auto Start",
    Callback = function(state)
        _G.AutoStartDungeon = state
        if state then task.spawn(AutoStartDungeon) end
    end
})

-- =========================================================
-- AUTO REPLAY DUNGEON

_G.AutoReplayDungeon = false

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local exitRemote = ReplicatedStorage.Systems.Dungeons.SetExitChoice

------------------------------------------------------------

local function AutoReplayDungeon()
    while _G.AutoReplayDungeon do
        local gui = player.PlayerGui:FindFirstChild("DungeonCleared")

        if gui then
            local frame = gui:FindFirstChild("Frame")
            local buttons = frame and frame:FindFirstChild("Buttons")

            if buttons then
                local nextDiff = buttons:FindFirstChild("NextDifficulty")
                local runAgain = buttons:FindFirstChild("RunAgain")

                -- prioritÃ© au NextDifficulty
                if nextDiff and nextDiff.Visible then
                    exitRemote:FireServer("NextDifficulty")

                elseif runAgain and runAgain.Visible then
                    exitRemote:FireServer("GoAgain")
                end
            end
        end

        task.wait(0.3)
    end
end

Tabs.Raid:AddToggle("AutoReplayDungeonToggle", {
    Title = "Auto Next / Run Again",
    Default = false,
    Callback = function(state)
        _G.AutoReplayDungeon = state
        if state then
            task.spawn(AutoReplayDungeon)
        end
    end
})

-- =========================================================
-- AUTO FARM

local tpHeight = 50
local tpSpeed = 200
local MAX_DISTANCE = 1000
local HIGH_HP = 3000000

local oscillationAmplitude = 20
local oscillationSpeed = 5

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local player = Players.LocalPlayer
local mobsFolder = Workspace:WaitForChild("Mobs")

local LOBBY_PLACE_IDS = {
    [94845773826960] = true,
    [126558459867198] = true,
    [94761525307396] = true
}

local function isLobby()
    return LOBBY_PLACE_IDS[game.PlaceId] == true
end

_G.AutoFarmEnabled = false

local function resetCharacter(char)
    if not char then return end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChild("Humanoid")

    if hrp then
        hrp.Velocity = Vector3.zero
        hrp.CanCollide = false
    end

    if humanoid then
        humanoid.PlatformStand = false
        humanoid:ChangeState(Enum.HumanoidStateType.Running)
    end
end

local function getNearestMob(hrp)
    local best, dist = nil, MAX_DISTANCE
    local bestHighHP, distHighHP = nil, MAX_DISTANCE

    for _, mob in ipairs(mobsFolder:GetDescendants()) do
        if mob:IsA("Model")
        and mob:FindFirstChild("HumanoidRootPart")
        and mob.Name ~= "TargetDummy"
        and mob:GetAttribute("Owner") == nil then

            local hp = mob:GetAttribute("HP") or 1
            local maxHp = mob:GetAttribute("MaxHP") or 1
            if hp > 0 then
                local d = (mob.HumanoidRootPart.Position - hrp.Position).Magnitude

                if maxHp == HIGH_HP then
                    if d < distHighHP then
                        distHighHP = d
                        bestHighHP = mob
                    end
                elseif d < dist then
                    dist = d
                    best = mob
                end
            end
        end
    end

    return bestHighHP or best
end

local function AutoFarm()
    local startTime = tick()

    while _G.AutoFarmEnabled do
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")

        if not hrp then
            task.wait()
            continue
        end

        local mob = getNearestMob(hrp)

        if mob and mob:FindFirstChild("HumanoidRootPart") then
            local timeElapsed = tick() - startTime
            local oscillation = math.sin(timeElapsed * oscillationSpeed) * oscillationAmplitude

            local targetPos = mob.HumanoidRootPart.Position + Vector3.new(0, tpHeight, 2 + oscillation)
            local dir = (targetPos - hrp.Position)

            if dir.Magnitude > 1 then
                hrp.Velocity = dir.Unit * (tpSpeed / 2)
            end

            hrp.CFrame = CFrame.new(hrp.Position, mob.HumanoidRootPart.Position)

            -- disable collisions
            for _, v in ipairs(char:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = false
                end
            end
        else
            for _, v in ipairs(char:GetDescendants()) do
                if v:IsA("BasePart") then
                    v.CanCollide = false
                end
            end

            task.wait(0.2)
        end

        task.wait()
    end

    -- final reset when disabled
    local char = player.Character
    if char then
        for _, v in ipairs(char:GetDescendants()) do
            if v:IsA("BasePart") then
                v.CanCollide = false
            end
        end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.Velocity = Vector3.zero
        end
    end
end


local Section = Tabs.Raid:AddSection("Auto Farm")

Tabs.Raid:AddToggle("AutoFarmToggle", {
    Title = "Auto TP",
    Default = false,
    Callback = function(state)
        _G.AutoFarmEnabled = state
        if state then
            task.spawn(AutoFarm)
        end
    end
})

Tabs.Raid:AddSlider("TPHeightSlider", {
    Title = "TP Height",
    Min = 10,
    Max = 150,
    Default = tpHeight,
    Rounding = 0,
    Callback = function(value)
        tpHeight = value
    end
})

Tabs.Raid:AddSlider("TPSpeedSlider", {
    Title = "TP Speed",
    Min = 50,
    Max = 500,
    Default = tpSpeed,
    Rounding = 0,
    Callback = function(value)
        tpSpeed = value
    end
})


-- =========================================================
-- Items















-- =========================================================
-- Sell

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local inventory = player:WaitForChild("PlayerGui"):WaitForChild("Profile"):WaitForChild("Inventory")

local sellItemEvent = ReplicatedStorage:WaitForChild("Systems"):WaitForChild("ItemSelling"):WaitForChild("SellItem")

_G.AutoSellEquipment = _G.AutoSellEquipment or false

_G.RarityToggles = _G.RarityToggles or {
    [1] = true,
    [2] = true,
    [3] = true,
    [4] = true,
    [5] = false,
    [6] = false,
    [7] = false, 
}

local rarityList = {
    [1] = "Commun",
    [2] = "Uncommun",
    [3] = "Rare",
    [4] = "Epic",
    [5] = "Legendary",
    [6] = "Mythic",
    [7] = "Primordial"
}

task.spawn(function()
    while true do
        if _G.AutoSellEquipment then
            for _, item in ipairs(inventory:GetChildren()) do
                if not _G.AutoSellEquipment then break end

                -- Ignore PetChest
                if not item.Name:find("PetChest") then
                    local rarity = item:FindFirstChild("Rarity")
                    if rarity and _G.RarityToggles[rarity.Value] then
                        sellItemEvent:FireServer({item}, {})
                        task.wait(0.1)
                    end
                end
            end
        end
        task.wait(1)
    end
end)

Tabs.Sell:AddToggle("AutoSellEquipmentToggle", {
    Title = "Auto Sell Equipment",
    Default = _G.AutoSellEquipment,
    Callback = function(state)
        _G.AutoSellEquipment = state
    end
})

for rarityId, rarityName in ipairs(rarityList) do
    Tabs.Sell:AddToggle("SellRarity_" .. rarityId, {
        Title = "Sell " .. rarityName,
        Default = _G.RarityToggles[rarityId],
        Callback = function(state)
            _G.RarityToggles[rarityId] = state
        end
    })
end


-- =========================================================
-- Misc

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local inventory = player:WaitForChild("PlayerGui"):WaitForChild("Profile"):WaitForChild("Inventory")
local openChestEvent = ReplicatedStorage:WaitForChild("Systems"):WaitForChild("Pets"):WaitForChild("OpenPetChest")

_G.AutoOpenPetChests = false

local function OpenPetChests()
    while _G.AutoOpenPetChests do
        for _, item in ipairs(inventory:GetChildren()) do
            if item.Name:sub(-8) == "PetChest" then
                openChestEvent:FireServer(item, 1)
                task.wait(0.1)
            end
        end
        task.wait(0.1)
    end
end

Tabs.Misc:AddToggle("AutoOpenPetChestsToggle", { 
    Title = "Auto PetChests",
    Default = _G.AutoOpenPetChests,
    Callback = function(state)
        _G.AutoOpenPetChests = state
        if state then
            task.spawn(OpenPetChests)
        end
    end
})
-- =========================================================
-- AUTO RE-INJECTIONS AUTOMATIQUE
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local AutoReInjectEnabled = false
local TeleportCheck = false

local queueteleport = queue_on_teleport or 
                      (syn and syn.queue_on_teleport) or 
                      (fluxus and fluxus.queue_on_teleport) or
                      queueonteleport

local ScriptURL = "https://raw.githubusercontent.com/Omegahub1/20-20-/refs/heads/main/Dungeon-heroes"

if queueteleport then
    LocalPlayer.OnTeleport:Connect(function(State)
        if AutoReInjectEnabled and not TeleportCheck then
            TeleportCheck = true
            local code = "repeat task.wait() until game:IsLoaded() wait(2) loadstring(game:HttpGet('" .. ScriptURL .. "'))()"
            queueteleport(code)
        end
    end)
end

Tabs.Misc:AddToggle("AutoReInject", {
    Title = "Auto Re-inject",
    Description = "Automatically re-inject script after teleporting",
    Default = false,
    Callback = function(Value)
        if not queueteleport then
            return
        end
        
        AutoReInjectEnabled = Value
        TeleportCheck = false
    end
})
-- =========================================================
-- Auto Claim Crystals

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local claimCrystals = ReplicatedStorage:WaitForChild("Systems"):WaitForChild("PremiumShop"):WaitForChild("ClaimFreeCrystals")

local autoClaim = false

Tabs.Misc:AddToggle("Auto Claim Crystals", {
    Title = "Auto Claim Crystals",
    Callback = function(state)
        autoClaim = state
        if autoClaim then
            spawn(function()
                while autoClaim do
                    claimCrystals:FireServer()
                    wait(1)
                end
            end)
        end
    end
})


-- =========================================================
-- RE-START AUTOMATIQUE APRÃˆS MORT

player.CharacterAdded:Connect(function()
    task.wait(0.5)

    if _G.KillAuraEnabled and not _G.KillAuraRunning then
        task.spawn(KillAura)
    end

    if _G.AutoFarmEnabled then
        task.spawn(AutoFarm)
    end
end)

-- =========================================================
-- CONFIG SYSTEM

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)
SaveManager:LoadAutoloadConfig()
Window:SelectTab(1)

-- =========================
-- MOBILE / PC BUTTON

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "FluentMobileButton"
screenGui.Parent = playerGui
screenGui.ResetOnSpawn = false

local openButton = Instance.new("ImageButton")
openButton.Size = UDim2.new(0, 40, 0, 40)
openButton.Position = UDim2.new(0, 10, 0, 10)
openButton.BackgroundColor3 = Color3.fromRGB(0,0,0)
openButton.BackgroundTransparency = 0.5
openButton.Image = "rbxassetid://133520358863074"
openButton.ScaleType = Enum.ScaleType.Fit
openButton.BorderSizePixel = 0
openButton.Parent = screenGui
openButton.ZIndex = 10

local uicorner = Instance.new("UICorner")
uicorner.CornerRadius = UDim.new(0, 20)
uicorner.Parent = openButton

local dragging
local dragInput
local dragStart
local startPos

local function update(input)
    local delta = input.Position - dragStart
    openButton.Position = UDim2.new(
        startPos.X.Scale, startPos.X.Offset + delta.X,
        startPos.Y.Scale, startPos.Y.Offset + delta.Y
    )
end

openButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = openButton.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

openButton.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

game:GetService("UserInputService").InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

openButton.MouseButton1Click:Connect(function()
    local VirtualInputManager = game:GetService("VirtualInputManager")
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftControl, false, game)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftControl, false, game)
end)

local function removeButton()
    if openButton and openButton.Parent then
        openButton:Destroy()
    end
end

if Window.UI and Window.UI.CloseButton then
    Window.UI.CloseButton.MouseButton1Click:Connect(function()
        removeButton()
    end)
else
    if Window.OnClose then
        local oldClose = Window.OnClose
        Window.OnClose = function()
            removeButton()
            if oldClose then oldClose() end
        end
    end
end
